<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LearningCPP — Навигатор</title>
  <style>
    :root {
      --bg: #0d1117;
      --panel: #161b22;
      --text: #c9d1d9;
      --muted: #8b949e;
      --accent: #2f81f7;
      --ok: #3fb950;
      --bad: #f85149;
      --border: #30363d;
      --shadow: rgba(0,0,0,.35);
    }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
      background: var(--bg);
      color: var(--text);
    }
    header {
      padding: 20px 18px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, #0d1117 0%, #0b0f14 100%);
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(8px);
    }
    header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: .2px;
    }
    header p {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 10px 30px var(--shadow);
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 980px) {
      .grid {
        grid-template-columns: 1fr 1fr 1fr;
      }
    }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    select, input {
      width: 100%;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0b0f14;
      color: var(--text);
      outline: none;
    }
    select:focus, input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(47,129,247,.18);
    }

    .row {
      margin-top: 12px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 980px) {
      .row {
        grid-template-columns: 1fr 1fr;
      }
    }

    .btnrow {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      cursor: pointer;
      border: 1px solid var(--border);
      background: #0b0f14;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    button:hover { border-color: var(--accent); }
    button:disabled {
      cursor: not-allowed;
      opacity: .55;
    }

    .status {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0b0f14;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    .status.ok { border-color: rgba(63,185,80,.45); }
    .status.bad { border-color: rgba(248,81,73,.45); }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      margin-right: 8px;
      vertical-align: baseline;
    }
    .pill.ok { color: var(--ok); border-color: rgba(63,185,80,.45); }
    .pill.bad { color: var(--bad); border-color: rgba(248,81,73,.45); }

    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    code { color: #d2a8ff; }

    .files {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
    }
    .files-head {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #0b0f14;
      border-bottom: 1px solid var(--border);
    }
    .files-head .left {
      display: inline-flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    .files-head small { color: var(--muted); }
    .files-list {
      max-height: 420px;
      overflow: auto;
      background: #0d1117;
    }
    ul { margin: 0; padding: 10px 18px; }
    li { margin: 6px 0; }

    .switch {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      user-select: none;
      cursor: pointer;
      color: var(--muted);
      font-size: 13px;
    }
    .switch input { width: auto; }

    footer {
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
  </style>
</head>
<body>
<header>
  <h1>LearningCPP — навигатор решений</h1>
  <p>Быстрый выбор «семестр → автор → ДЗ» и переход в нужную папку/файл без 404. Ссылка сохраняется в <code>#hash</code> и её можно шарить.</p>
</header>

<main>
  <div class="card">
    <div class="grid">
      <div>
        <label for="semester">Семестр</label>
        <select id="semester"></select>
      </div>
      <div>
        <label for="author">Автор</label>
        <select id="author" disabled></select>
      </div>
      <div>
        <label for="hw">Домашка</label>
        <select id="hw" disabled></select>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="task">Номер задания (опционально, чтобы быстро найти файл)</label>
        <input id="task" inputmode="numeric" placeholder="Например: 1" />
      </div>
      <div>
        <label for="filter">Фильтр по имени файла (подстрока)</label>
        <input id="filter" placeholder="Например: task, matrix, 3" />
      </div>
    </div>

    <div class="btnrow">
      <button id="openFolder" disabled>Открыть папку</button>
      <button id="findTask" disabled>Найти задание</button>
      <button id="openFile" disabled>Открыть выбранный файл</button>
      <button id="copyLink">Скопировать ссылку</button>
    </div>

    <div id="status" class="status">Загрузка индекса…</div>

    <div id="files" class="files" style="display:none;">
      <div class="files-head">
        <div class="left">
          <span class="pill">FILES</span>
          <small id="filesMeta">—</small>
          <label class="switch" title="Показывать только .cpp">
            <input id="onlyCpp" type="checkbox" checked />
            Только .cpp
          </label>
        </div>
        <div style="min-width: 320px; flex: 1; max-width: 520px;">
          <select id="fileSelect" disabled></select>
        </div>
      </div>
      <div class="files-list">
        <ul id="filesList"></ul>
      </div>
    </div>

    <footer>
      <div><span class="pill">SCAN</span>Ожидаемый формат решений: <code>Semester_*/&lt;author&gt;/HW_*/...</code>. Навигатор строит индекс одним запросом к Git Trees API и кэширует его в <code>localStorage</code>.</div>
      <div><span class="pill">TIP</span>Можно выбрать другую ветку через <code>?ref=master</code> или <code>?ref=Vennilay</code>.</div>
    </footer>
  </div>
</main>

<script>
  // ===== config =====
  const OWNER = 'Vennilay';
  const REPO  = 'LearningCPP';

  const qs = new URLSearchParams(location.search);
  const REF = (qs.get('ref') || 'Vennilay').trim();

  const SEMESTER_RE = /^Semester_\d+$/i;
  const HW_RE = /^HW[_-]?\d+$/i;

  // ===== elements =====
  const elSemester  = document.getElementById('semester');
  const elAuthor    = document.getElementById('author');
  const elHw        = document.getElementById('hw');
  const elTask      = document.getElementById('task');
  const elFilter    = document.getElementById('filter');
  const elStatus    = document.getElementById('status');

  const elFilesWrap = document.getElementById('files');
  const elFilesMeta = document.getElementById('filesMeta');
  const elOnlyCpp   = document.getElementById('onlyCpp');
  const elFileSelect= document.getElementById('fileSelect');
  const elFilesList = document.getElementById('filesList');

  const btnOpenFolder = document.getElementById('openFolder');
  const btnFindTask   = document.getElementById('findTask');
  const btnOpenFile   = document.getElementById('openFile');
  const btnCopyLink   = document.getElementById('copyLink');

  // ===== helpers =====
  function setStatus(kind, html) {
    elStatus.className = 'status' + (kind ? ` ${kind}` : '');
    elStatus.innerHTML = html;
  }

  function ghTree(path) {
    const safe = path.split('/').filter(Boolean).map(encodeURIComponent).join('/');
    return `https://github.com/${OWNER}/${REPO}/tree/${encodeURIComponent(REF)}/${safe}`;
  }

  function ghBlob(path) {
    const safe = path.split('/').filter(Boolean).map(encodeURIComponent).join('/');
    return `https://github.com/${OWNER}/${REPO}/blob/${encodeURIComponent(REF)}/${safe}`;
  }

  function apiTreeUrl() {
    // GitHub REST API: GET /repos/{owner}/{repo}/git/trees/{tree_sha}?recursive=1
    return `https://api.github.com/repos/${OWNER}/${REPO}/git/trees/${encodeURIComponent(REF)}?recursive=1`;
  }

  function byLocale(a, b) {
    return a.localeCompare(b, 'en', { numeric: true, sensitivity: 'base' });
  }

  function hashGet() {
    const h = location.hash.replace(/^#/, '');
    const p = new URLSearchParams(h);
    return {
      s: p.get('s') || '',
      a: p.get('a') || '',
      hw: p.get('hw') || '',
      f: p.get('f') || '',
      q: p.get('q') || '',
      t: p.get('t') || '',
    };
  }

  function hashSet({ s, a, hw, f, q, t }) {
    const p = new URLSearchParams();
    if (s) p.set('s', s);
    if (a) p.set('a', a);
    if (hw) p.set('hw', hw);
    if (f) p.set('f', f);
    if (q) p.set('q', q);
    if (t) p.set('t', t);
    const next = '#' + p.toString();
    if (location.hash !== next) history.replaceState(null, '', next);
  }

  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position = 'fixed';
      ta.style.left = '-9999px';
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand('copy');
      ta.remove();
      return ok;
    }
  }

  // ===== index model =====
  // index.semesters[semester].authors[author].hws[hw] = { folderPath, files: [{path, rel, name}] }
  const index = { semesters: {} };

  function ensure(obj, key, init) {
    if (!obj[key]) obj[key] = init;
    return obj[key];
  }

  function buildIndex(treeItems) {
    index.semesters = {};

    for (const it of treeItems) {
      if (!it || it.type !== 'blob' || typeof it.path !== 'string') continue;

      const parts = it.path.split('/');
      if (parts.length < 4) continue;

      const [semester, author, hw] = parts;
      if (!SEMESTER_RE.test(semester)) continue;
      if (!HW_RE.test(hw)) continue;

      const rel = parts.slice(3).join('/');
      const folderPath = `${semester}/${author}/${hw}`;

      const sem = ensure(index.semesters, semester, { authors: {} });
      const a = ensure(sem.authors, author, { hws: {} });
      const h = ensure(a.hws, hw, { folderPath, files: [] });

      h.files.push({
        path: it.path,
        rel,
        name: parts[parts.length - 1],
      });
    }

    // normalize: sort everything
    for (const semester of Object.keys(index.semesters)) {
      const sem = index.semesters[semester];
      for (const author of Object.keys(sem.authors)) {
        const a = sem.authors[author];
        for (const hw of Object.keys(a.hws)) {
          a.hws[hw].files.sort((x, y) => byLocale(x.rel, y.rel));
        }
      }
    }
  }

  async function loadTreeCached() {
    const key = `lc-tree:${OWNER}/${REPO}@${REF}`;
    const cachedRaw = localStorage.getItem(key);
    let cached = null;

    if (cachedRaw) {
      try { cached = JSON.parse(cachedRaw); } catch { cached = null; }
    }

    const headers = { 'Accept': 'application/vnd.github+json' };
    if (cached && cached.etag) headers['If-None-Match'] = cached.etag;

    const res = await fetch(apiTreeUrl(), { headers });

    if (res.status === 304 && cached && cached.tree) {
      return { tree: cached.tree, fromCache: true, truncated: !!cached.truncated };
    }

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`GitHub API error: ${res.status} ${text}`);
    }

    const json = await res.json();
    const etag = res.headers.get('ETag');

    const payload = {
      fetchedAt: Date.now(),
      etag,
      truncated: !!json.truncated,
      tree: Array.isArray(json.tree) ? json.tree : [],
    };

    try { localStorage.setItem(key, JSON.stringify(payload)); } catch {}

    return { tree: payload.tree, fromCache: false, truncated: payload.truncated };
  }

  function fillSelect(el, placeholder, values) {
    el.innerHTML = '';
    const ph = document.createElement('option');
    ph.value = '';
    ph.textContent = placeholder;
    el.appendChild(ph);

    for (const v of values) {
      const opt = document.createElement('option');
      opt.value = v;
      opt.textContent = v;
      el.appendChild(opt);
    }
  }

  function getCurrentModel() {
    const s = elSemester.value;
    const a = elAuthor.value;
    const hw = elHw.value;
    const sem = index.semesters[s];
    const author = sem?.authors?.[a];
    const h = author?.hws?.[hw];
    return { s, a, hw, h };
  }

  function renderFiles() {
    const { s, a, hw, h } = getCurrentModel();

    const filter = elFilter.value.trim().toLowerCase();
    const onlyCpp = !!elOnlyCpp.checked;

    elFilesList.innerHTML = '';

    if (!h) {
      elFilesWrap.style.display = 'none';
      elFileSelect.disabled = true;
      btnOpenFolder.disabled = true;
      btnFindTask.disabled = true;
      btnOpenFile.disabled = true;
      return;
    }

    btnOpenFolder.disabled = false;
    btnFindTask.disabled = false;

    const all = h.files;
    const shown = all.filter(f => {
      if (onlyCpp && !f.name.toLowerCase().endsWith('.cpp')) return false;
      if (filter && !f.rel.toLowerCase().includes(filter)) return false;
      return true;
    });

    elFilesWrap.style.display = '';
    elFilesMeta.textContent = `${s} / ${a} / ${hw} — файлов: ${shown.length} (всего ${all.length})`;

    // list
    for (const f of shown) {
      const li = document.createElement('li');
      li.innerHTML = `<a href="${ghBlob(f.path)}" target="_blank" rel="noreferrer">${escapeHtml(f.rel)}</a>`;
      elFilesList.appendChild(li);
    }

    // select
    fillSelect(elFileSelect, '— выберите файл —', shown.map(x => x.rel));
    elFileSelect.disabled = false;
    btnOpenFile.disabled = true;

    // restore selected file from hash if present
    const h0 = hashGet();
    if (h0.f) {
      const idx = shown.findIndex(x => x.rel === h0.f);
      if (idx >= 0) {
        elFileSelect.value = shown[idx].rel;
        btnOpenFile.disabled = false;
      }
    }

    hashSet({ s, a, hw, f: elFileSelect.value || '', q: elFilter.value.trim(), t: elTask.value.trim() });
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function scoreTaskCandidate(fileName, n) {
    const lower = fileName.toLowerCase();
    const num = String(Number(n));
    const numRe = new RegExp(`(^|[^0-9])${num}([^0-9]|$)`);

    if (lower === `task${num}.cpp`) return 100;
    if (lower === `${num}.cpp`) return 98;
    if (new RegExp(`^task[_-]?${num}\\.cpp$`, 'i').test(fileName)) return 95;
    if (new RegExp(`^${num}[_-]`, 'i').test(fileName)) return 90;
    if (numRe.test(lower)) return 80;
    if (lower.includes(num)) return 50;
    return 0;
  }

  function findBestByTask(files, taskNum) {
    const n = String(taskNum).trim();
    if (!n || isNaN(Number(n))) return null;

    let best = null;
    let bestScore = 0;

    for (const f of files) {
      const s = scoreTaskCandidate(f.name, n);
      if (s > bestScore) {
        bestScore = s;
        best = f;
      }
    }

    return bestScore > 0 ? best : null;
  }

  function updateAuthors() {
    const s = elSemester.value;
    const sem = index.semesters[s];
    if (!sem) {
      elAuthor.disabled = true;
      elHw.disabled = true;
      fillSelect(elAuthor, '— выберите автора —', []);
      fillSelect(elHw, '— выберите домашку —', []);
      setStatus('bad', `<span class="pill bad">ERR</span>Не найден семестр <code>${escapeHtml(s)}</code> в индексе.`);
      renderFiles();
      return;
    }

    const authors = Object.keys(sem.authors).sort(byLocale);
    fillSelect(elAuthor, '— выберите автора —', authors);
    elAuthor.disabled = false;

    fillSelect(elHw, '— выберите домашку —', []);
    elHw.disabled = true;

    setStatus('', 'Выберите автора.');
    renderFiles();
  }

  function updateHws() {
    const { s, a } = getCurrentModel();
    const sem = index.semesters[s];
    const author = sem?.authors?.[a];

    if (!author) {
      elHw.disabled = true;
      fillSelect(elHw, '— выберите домашку —', []);
      setStatus('bad', `<span class="pill bad">404</span>Для <b>${escapeHtml(a || '—')}</b> нет папки в <code>${escapeHtml(s)}</code> (или нет файлов в формате <code>HW_*</code>).`);
      renderFiles();
      return;
    }

    const hws = Object.keys(author.hws).sort(byLocale);
    fillSelect(elHw, '— выберите домашку —', hws);
    elHw.disabled = false;

    if (hws.length === 0) {
      setStatus('bad', `<span class="pill bad">EMPTY</span>У <b>${escapeHtml(a)}</b> нет <code>HW_*</code> (или в них нет файлов).`);
    } else {
      setStatus('', 'Выберите домашку.');
    }

    renderFiles();
  }

  function updateSelectionFromHash() {
    const h = hashGet();

    if (h.q) elFilter.value = h.q;
    if (h.t) elTask.value = h.t;

    // semester
    if (h.s && Array.from(elSemester.options).some(o => o.value === h.s)) {
      elSemester.value = h.s;
    }

    updateAuthors();

    // author
    if (h.a && Array.from(elAuthor.options).some(o => o.value === h.a)) {
      elAuthor.value = h.a;
      updateHws();
    }

    // hw
    if (h.hw && Array.from(elHw.options).some(o => o.value === h.hw)) {
      elHw.value = h.hw;
    }

    renderFiles();
  }

  // ===== events =====
  elSemester.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: '', hw: '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });
    updateAuthors();
  });

  elAuthor.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, hw: '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });
    updateHws();
  });

  elHw.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, hw: elHw.value, f: '', q: elFilter.value.trim(), t: elTask.value.trim() });

    const { h } = getCurrentModel();
    if (!h) {
      setStatus('bad', `<span class="pill bad">404</span>Эта домашка не найдена в индексе.`);
    } else {
      setStatus('ok', `<span class="pill ok">OK</span>Найдена папка: <a href="${ghTree(h.folderPath)}" target="_blank" rel="noreferrer">${escapeHtml(h.folderPath)}</a>`);
    }

    renderFiles();
  });

  elOnlyCpp.addEventListener('change', renderFiles);
  elFilter.addEventListener('input', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, hw: elHw.value, f: elFileSelect.value || '', q: elFilter.value.trim(), t: elTask.value.trim() });
    renderFiles();
  });

  elTask.addEventListener('input', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, hw: elHw.value, f: elFileSelect.value || '', q: elFilter.value.trim(), t: elTask.value.trim() });
  });

  elFileSelect.addEventListener('change', () => {
    const rel = elFileSelect.value;
    btnOpenFile.disabled = !rel;
    hashSet({ s: elSemester.value, a: elAuthor.value, hw: elHw.value, f: rel, q: elFilter.value.trim(), t: elTask.value.trim() });
  });

  btnOpenFolder.addEventListener('click', () => {
    const { h } = getCurrentModel();
    if (!h) return;
    location.href = ghTree(h.folderPath);
  });

  btnOpenFile.addEventListener('click', () => {
    const { h } = getCurrentModel();
    if (!h) return;
    const rel = elFileSelect.value;
    if (!rel) return;
    const file = h.files.find(x => x.rel === rel);
    if (!file) return;
    location.href = ghBlob(file.path);
  });

  btnFindTask.addEventListener('click', () => {
    const { h } = getCurrentModel();
    const task = elTask.value.trim();
    if (!h) {
      setStatus('bad', `<span class="pill bad">ERR</span>Сначала выберите семестр/автора/домашку.`);
      return;
    }

    if (!task) {
      setStatus('ok', `<span class="pill ok">OK</span>Введите номер задания, либо пользуйтесь списком файлов.`);
      return;
    }

    const best = findBestByTask(h.files, task);
    if (!best) {
      setStatus('bad', `<span class="pill bad">NO</span>Не удалось сопоставить задание <b>${escapeHtml(task)}</b> ни с одним файлом в <a href="${ghTree(h.folderPath)}" target="_blank" rel="noreferrer">${escapeHtml(h.folderPath)}</a>.`);
      return;
    }

    setStatus('ok', `<span class="pill ok">FOUND</span>Задание <b>${escapeHtml(task)}</b> похоже на: <a href="${ghBlob(best.path)}" target="_blank" rel="noreferrer">${escapeHtml(best.rel)}</a>`);

    // try set in UI
    elFilter.value = '';
    elOnlyCpp.checked = best.name.toLowerCase().endsWith('.cpp');
    renderFiles();

    // select
    if (Array.from(elFileSelect.options).some(o => o.value === best.rel)) {
      elFileSelect.value = best.rel;
      btnOpenFile.disabled = false;
      hashSet({ s: elSemester.value, a: elAuthor.value, hw: elHw.value, f: best.rel, q: elFilter.value.trim(), t: elTask.value.trim() });
    }
  });

  btnCopyLink.addEventListener('click', async () => {
    const url = location.origin + location.pathname + location.search + location.hash;
    const ok = await copyToClipboard(url);
    setStatus(ok ? 'ok' : 'bad', `${ok ? '<span class="pill ok">OK</span>' : '<span class="pill bad">ERR</span>'}Ссылка ${ok ? 'скопирована' : 'не скопирована'}: <code>${escapeHtml(url)}</code>`);
  });

  // ===== init =====
  (async function init() {
    try {
      setStatus('', `Загрузка индекса из ветки <code>${escapeHtml(REF)}</code>…`);

      const { tree, fromCache, truncated } = await loadTreeCached();
      if (truncated) {
        setStatus('bad', `<span class="pill bad">WARN</span>GitHub вернул <code>truncated=true</code> (репозиторий слишком большой для одного recursive tree). Индекс может быть неполным.`);
      }

      buildIndex(tree);

      const semesters = Object.keys(index.semesters).sort(byLocale);
      if (semesters.length === 0) {
        setStatus('bad', `<span class="pill bad">EMPTY</span>Не найдено решений в формате <code>Semester_*/&lt;author&gt;/HW_*/...</code> в ветке <code>${escapeHtml(REF)}</code>.`);
        fillSelect(elSemester, '— семестр не найден —', []);
        elAuthor.disabled = true;
        elHw.disabled = true;
        return;
      }

      fillSelect(elSemester, '— выберите семестр —', semesters);
      elSemester.value = semesters[0];

      updateSelectionFromHash();

      if (!truncated) {
        setStatus('ok', `${fromCache ? '<span class="pill ok">CACHE</span>' : '<span class="pill ok">OK</span>'}Индекс готов. Выберите автора и ДЗ.`);
      }
    } catch (err) {
      const msg = String(err);
      setStatus('bad', `<span class="pill bad">ERR</span>${escapeHtml(msg)}`);
    }
  })();
</script>
</body>
</html>
