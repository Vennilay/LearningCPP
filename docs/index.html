<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LearningCPP — Навигатор</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.08);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --accent: #6ea8ff;
      --accent2: #8b5cf6;
      --ok: #22c55e;
      --bad: #ef4444;
      --border: rgba(255,255,255,.12);
      --shadow: rgba(0,0,0,.42);
      --radius: 14px;
    }

    *, *::before, *::after { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(110,168,255,.25), transparent 60%),
        radial-gradient(900px 520px at 90% 0%, rgba(139,92,246,.22), transparent 55%),
        radial-gradient(800px 600px at 70% 110%, rgba(34,197,94,.12), transparent 60%),
        var(--bg);
      color: var(--text);
    }
    header {
      padding: 18px 18px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(11,16,32,.92) 0%, rgba(11,16,32,.70) 100%);
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(8px);
    }
    header h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: .2px;
    }
    header p {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    main {
      max-width: 1180px;
      margin: 0 auto;
      padding: 18px;
    }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.07) 0%, rgba(255,255,255,.05) 100%);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: 0 18px 44px var(--shadow);
    }
    .layout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 980px) {
      .layout {
        grid-template-columns: 420px 1fr;
        align-items: start;
      }
    }
    .panel-title {
      margin: 0 0 10px;
      font-size: 13px;
      color: var(--muted);
      letter-spacing: .2px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .panel-title b {
      color: var(--text);
      font-size: 14px;
      letter-spacing: .2px;
    }
    .hidden { display: none !important; }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    select, input {
      width: 100%;
      min-width: 0;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(11,16,32,.55);
      color: var(--text);
      outline: none;
      box-sizing: border-box;
    }
    select:focus, input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(110,168,255,.20);
    }

    .row {
      margin-top: 12px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 980px) {
      .row {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Buttons: use grid to guarantee no overlaps on narrow widths */
    .btnrow {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(min(220px, 100%), 1fr));
      gap: 10px;
      align-items: stretch;
    }
    button {
      cursor: pointer;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,.09) 0%, rgba(255,255,255,.06) 100%);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
      box-sizing: border-box;
      white-space: nowrap;
    }
    @media (max-width: 460px) {
      button {
        white-space: normal;
      }
    }
    button:hover { border-color: rgba(110,168,255,.45); }
    button:disabled {
      cursor: not-allowed;
      opacity: .55;
    }

    .primary {
      border-color: rgba(110,168,255,.55);
      background: linear-gradient(180deg, rgba(110,168,255,.28) 0%, rgba(110,168,255,.16) 100%);
    }

    .status {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(11,16,32,.55);
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    .status.ok { border-color: rgba(63,185,80,.45); }
    .status.bad { border-color: rgba(248,81,73,.45); }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      margin-right: 8px;
      vertical-align: baseline;
      background: rgba(255,255,255,.04);
    }
    .pill.ok { color: var(--ok); border-color: rgba(63,185,80,.45); }
    .pill.bad { color: var(--bad); border-color: rgba(248,81,73,.45); }

    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    code { color: #d2a8ff; }

    .files {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
    }
    /* Header: switch from flex to grid so the select never overlaps other controls */
    .files-head {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(240px, 520px);
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      background: rgba(255,255,255,.04);
      border-bottom: 1px solid var(--border);
    }
    @media (max-width: 760px) {
      .files-head {
        grid-template-columns: 1fr;
      }
    }
    .files-head .left {
      display: inline-flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      min-width: 0;
    }
    .files-head .right {
      width: 100%;
      max-width: 520px;
      min-width: 0;
      justify-self: end;
    }
    @media (max-width: 760px) {
      .files-head .right {
        max-width: none;
        justify-self: stretch;
      }
    }
    .files-head small { color: var(--muted); }
    .files-list {
      max-height: 420px;
      overflow: auto;
      background: rgba(11,16,32,.30);
    }
    ul { margin: 0; padding: 10px 18px; }
    li { margin: 6px 0; }

    .switch {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      user-select: none;
      cursor: pointer;
      color: var(--muted);
      font-size: 13px;
    }
    .switch input { width: auto; }

    footer {
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
  </style>
</head>
<body>
<header>
  <h1>LearningCPP — навигатор решений</h1>
  <p>Выбирай семестр и автора, находи нужную задачу и открывай файл на GitHub. Настройки сохраняются в <code>#hash</code>.</p>
</header>

<main>
  <div class="card">
    <div class="layout">
      <div>
        <div class="panel-title"><span class="pill">НАВИГАЦИЯ</span><b>Выбор</b></div>
        <div class="grid">
          <div>
            <label for="semester">Семестр</label>
            <select id="semester"></select>
          </div>
          <div>
            <label for="author">Автор</label>
            <select id="author" disabled></select>
          </div>
          <div>
            <label for="subject">Раздел</label>
            <select id="subject" disabled></select>
          </div>
          <div id="practiceWrap">
            <label for="practice">Практика</label>
            <select id="practice" disabled></select>
          </div>
        </div>

        <div class="row">
          <div>
            <label for="task">Номер задачи (быстрый поиск)</label>
            <input id="task" inputmode="numeric" placeholder="Например: 1" />
          </div>
          <div>
            <label for="filter">Фильтр по имени файла</label>
            <input id="filter" placeholder="Например: task, matrix, 3" />
          </div>
        </div>

        <div class="btnrow">
          <button id="openFolder" class="primary" disabled>Открыть папку</button>
          <button id="findTask" disabled>Найти задачу</button>
          <button id="openFile" disabled>Открыть файл</button>
          <button id="copyLink">Скопировать ссылку</button>
        </div>

        <div id="status" class="status">Загрузка индекса…</div>
      </div>

      <div>
        <div class="panel-title"><span class="pill">ФАЙЛЫ</span><b>Список</b> <small id="filesMeta" style="margin-left:auto; color: var(--muted);">—</small></div>
        <div id="files" class="files" style="display:none;">
          <div class="files-head">
            <div class="left">
              <label class="switch" title="Показывать только .cpp">
                <input id="onlyCpp" type="checkbox" checked />
                Только .cpp
              </label>
            </div>
            <div class="right">
              <select id="fileSelect" disabled></select>
            </div>
          </div>
          <div class="files-list">
            <ul id="filesList"></ul>
          </div>
        </div>

        <footer>
          <details>
            <summary>Справка</summary>
            <div style="margin-top:10px;">
              <div>Поддерживаются структуры: <code>Semester_1/&lt;author&gt;/HW_*/...</code> и <code>Semester_2/&lt;author&gt;/{OOP,AI_BigData,DataStructures,Informatics}/PR_*/...</code>.</div>
              <div style="margin-top:6px;">Можно выбрать другую ветку через <code>?ref=master</code> или <code>?ref=Vennilay</code>. Индекс кэшируется в <code>localStorage</code>.</div>
            </div>
          </details>
        </footer>
      </div>
    </div>
  </div>
</main>

<script>
  // ===== config =====
  const OWNER = 'Vennilay';
  const REPO  = 'LearningCPP';

  const qs = new URLSearchParams(location.search);
  const REF = (qs.get('ref') || 'Vennilay').trim();

  const SEMESTER_RE = /^Semester_\d+$/i;
  const SUBJECT_RE = /^(OOP|AI_BigData|DataStructures|Informatics)$/i;
  const PR_RE = /^PR[_-]?\d+$/i;
  const HW_RE = /^HW[_-]?\d+$/i;

  // Маппинг названий
  const SUBJECT_NAMES = {
    'OOP': 'ООП',
    'AI_BigData': 'ИИ и БД',
    'DataStructures': 'Структуры данных',
    'Informatics': 'Информатика'
  };

  const SUBJECT_CODES = {
    'ООП': 'OOP',
    'ИИ и БД': 'AI_BigData',
    'Структуры данных': 'DataStructures',
    'Информатика': 'Informatics'
  };

  // ===== elements =====
  const elSemester  = document.getElementById('semester');
  const elAuthor    = document.getElementById('author');
  const elSubject   = document.getElementById('subject');
  const elPractice  = document.getElementById('practice');
  const elPracticeWrap = document.getElementById('practiceWrap');
  const elTask      = document.getElementById('task');
  const elFilter    = document.getElementById('filter');
  const elStatus    = document.getElementById('status');

  const elFilesWrap = document.getElementById('files');
  const elFilesMeta = document.getElementById('filesMeta');
  const elOnlyCpp   = document.getElementById('onlyCpp');
  const elFileSelect= document.getElementById('fileSelect');
  const elFilesList = document.getElementById('filesList');

  const btnOpenFolder = document.getElementById('openFolder');
  const btnFindTask   = document.getElementById('findTask');
  const btnOpenFile   = document.getElementById('openFile');
  const btnCopyLink   = document.getElementById('copyLink');

  // ===== helpers =====
  function setStatus(kind, html) {
    elStatus.className = 'status' + (kind ? ` ${kind}` : '');
    elStatus.innerHTML = html;
  }

  function ghTree(path) {
    const safe = path.split('/').filter(Boolean).map(encodeURIComponent).join('/');
    return `https://github.com/${OWNER}/${REPO}/tree/${encodeURIComponent(REF)}/${safe}`;
  }

  function ghBlob(path) {
    const safe = path.split('/').filter(Boolean).map(encodeURIComponent).join('/');
    return `https://github.com/${OWNER}/${REPO}/blob/${encodeURIComponent(REF)}/${safe}`;
  }

  function apiTreeUrl() {
    // GitHub REST API: GET /repos/{owner}/{repo}/git/trees/{tree_sha}?recursive=1
    return `https://api.github.com/repos/${OWNER}/${REPO}/git/trees/${encodeURIComponent(REF)}?recursive=1`;
  }

  function byLocale(a, b) {
    return a.localeCompare(b, 'ru', { numeric: true, sensitivity: 'base' });
  }

  function semesterToDisplay(name) {
    const match = name.match(/^Semester_(\d+)$/i);
    return match ? `Семестр ${match[1]}` : name;
  }

  function semesterFromDisplay(display) {
    const match = display.match(/^Семестр (\d+)$/);
    return match ? `Semester_${match[1]}` : display;
  }

  function subjectToDisplay(code) {
    const hw = String(code || '').match(/^HW[_-]?(\d+)$/i);
    if (hw) return `Домашнее задание ${hw[1]}`;
    return SUBJECT_NAMES[code] || code;
  }

  function subjectFromDisplay(display) {
    const hw = String(display || '').match(/^Домашнее задание (\d+)$/);
    if (hw) return `HW_${hw[1]}`;
    return SUBJECT_CODES[display] || display;
  }

  function practiceToDisplay(code) {
    const pr = String(code || '').match(/^PR[_-]?(\d+)$/i);
    if (pr) return `Практика ${pr[1]}`;
    return code;
  }

  function practiceFromDisplay(display) {
    const pr = String(display || '').match(/^Практика (\d+)$/);
    if (pr) return `PR_${pr[1]}`;
    return display;
  }

  function hashGet() {
    const h = location.hash.replace(/^#/, '');
    const p = new URLSearchParams(h);
    return {
      s: p.get('s') || '',
      a: p.get('a') || '',
      sub: p.get('sub') || '',
      pr: p.get('pr') || '',
      f: p.get('f') || '',
      q: p.get('q') || '',
      t: p.get('t') || '',
    };
  }

  function hashSet({ s, a, sub, pr, f, q, t }) {
    const p = new URLSearchParams();
    if (s) p.set('s', s);
    if (a) p.set('a', a);
    if (sub) p.set('sub', sub);
    if (pr) p.set('pr', pr);
    if (f) p.set('f', f);
    if (q) p.set('q', q);
    if (t) p.set('t', t);
    const next = '#' + p.toString();
    if (location.hash !== next) history.replaceState(null, '', next);
  }

  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position = 'fixed';
      ta.style.left = '-9999px';
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand('copy');
      ta.remove();
      return ok;
    }
  }

  // ===== index model =====
  // index.semesters[semester].authors[author].subjects[subject].prs[pr] = { folderPath, files: [{path, rel, name}] }
  const index = { semesters: {} };

  function ensure(obj, key, init) {
    if (!obj[key]) obj[key] = init;
    return obj[key];
  }

  function buildIndex(treeItems) {
    index.semesters = {};

    for (const it of treeItems) {
      if (!it || it.type !== 'blob' || typeof it.path !== 'string') continue;

      const parts = it.path.split('/');
      if (parts.length < 3) continue;

      const semester = parts[0];
      const author = parts[1];
      const third = parts[2];
      const fourth = parts[3];

      if (!SEMESTER_RE.test(semester)) continue;

      let subject = '';
      let pr = '';
      let rel = '';
      let folderPath = '';

      // Semester_2/.../{subject}/PR_*/...
      if (parts.length >= 5 && SUBJECT_RE.test(third) && PR_RE.test(fourth || '')) {
        subject = third;
        pr = fourth;
        rel = parts.slice(4).join('/');
        folderPath = `${semester}/${author}/${subject}/${pr}`;
      }
      // Semester_1/.../HW_*/...
      else if (parts.length >= 4 && HW_RE.test(third)) {
        subject = third.replace('-', '_');
        pr = subject;
        rel = parts.slice(3).join('/');
        folderPath = `${semester}/${author}/${subject}`;
      } else {
        continue;
      }

      const sem = ensure(index.semesters, semester, { authors: {} });
      const a = ensure(sem.authors, author, { subjects: {} });
      const sub = ensure(a.subjects, subject, { prs: {} });
      const p = ensure(sub.prs, pr, { folderPath, files: [] });

      p.files.push({
        path: it.path,
        rel,
        name: parts[parts.length - 1],
      });
    }

    // normalize: sort everything
    for (const semester of Object.keys(index.semesters)) {
      const sem = index.semesters[semester];
      for (const author of Object.keys(sem.authors)) {
        const a = sem.authors[author];
        for (const subject of Object.keys(a.subjects)) {
          const sub = a.subjects[subject];
          for (const pr of Object.keys(sub.prs)) {
            sub.prs[pr].files.sort((x, y) => byLocale(x.rel, y.rel));
          }
        }
      }
    }
  }

  async function loadTreeCached() {
    const key = `lc-tree:${OWNER}/${REPO}@${REF}`;
    const cachedRaw = localStorage.getItem(key);
    let cached = null;

    if (cachedRaw) {
      try { cached = JSON.parse(cachedRaw); } catch { cached = null; }
    }

    const headers = { 'Accept': 'application/vnd.github+json' };
    if (cached && cached.etag) headers['If-None-Match'] = cached.etag;

    const res = await fetch(apiTreeUrl(), { headers });

    if (res.status === 304 && cached && cached.tree) {
      return { tree: cached.tree, fromCache: true, truncated: !!cached.truncated };
    }

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`GitHub API error: ${res.status} ${text}`);
    }

    const json = await res.json();
    const etag = res.headers.get('ETag');

    const payload = {
      fetchedAt: Date.now(),
      etag,
      truncated: !!json.truncated,
      tree: Array.isArray(json.tree) ? json.tree : [],
    };

    try { localStorage.setItem(key, JSON.stringify(payload)); } catch {}

    return { tree: payload.tree, fromCache: false, truncated: payload.truncated };
  }

  function fillSelect(el, placeholder, values) {
    el.innerHTML = '';
    const ph = document.createElement('option');
    ph.value = '';
    ph.textContent = placeholder;
    el.appendChild(ph);

    for (const v of values) {
      const opt = document.createElement('option');
      opt.value = v;
      opt.textContent = v;
      el.appendChild(opt);
    }
  }

  function getCurrentModel() {
    const sDisp = elSemester.value;
    const a = elAuthor.value;
    const subDisp = elSubject.value;
    const prDisp = elPractice.value;

    const s = semesterFromDisplay(sDisp);
    const sub = subjectFromDisplay(subDisp);
    const pr = practiceFromDisplay(prDisp);

    const sem = index.semesters[s];
    const author = sem?.authors?.[a];
    const subject = author?.subjects?.[sub];
    return { sDisp, s, a, subDisp, sub, prDisp, pr, subject };
  }

  function renderFiles() {
    const { sDisp, s, a, subDisp, sub, prDisp, pr, subject } = getCurrentModel();

    const filter = elFilter.value.trim().toLowerCase();
    const onlyCpp = !!elOnlyCpp.checked;

    elFilesList.innerHTML = '';

    if (!subject) {
      elFilesWrap.style.display = 'none';
      elFileSelect.disabled = true;
      btnOpenFolder.disabled = true;
      btnFindTask.disabled = true;
      btnOpenFile.disabled = true;
      return;
    }

    // Collect files depending on practice selection
    const allFiles = [];
    for (const p of Object.values(subject.prs)) allFiles.push(...p.files);

    const selectedPractice = (pr && subject.prs?.[pr]) ? pr : '';
    const baseFiles = selectedPractice ? subject.prs[selectedPractice].files : allFiles;

    const shown = baseFiles.filter(f => {
      if (onlyCpp && !f.name.toLowerCase().endsWith('.cpp')) return false;
      if (filter && !f.rel.toLowerCase().includes(filter)) return false;
      return true;
    });

    btnOpenFolder.disabled = false;
    btnFindTask.disabled = false;

    elFilesWrap.style.display = '';
    const practiceLabel = (!elPractice.disabled && prDisp) ? ` / ${prDisp}` : '';
    elFilesMeta.textContent = `${sDisp} / ${a} / ${subDisp}${practiceLabel} — файлов: ${shown.length} (всего ${allFiles.length})`;

    // list
    for (const f of shown) {
      const li = document.createElement('li');
      li.innerHTML = `<a href="${ghBlob(f.path)}" target="_blank" rel="noreferrer">${escapeHtml(f.rel)}</a>`;
      elFilesList.appendChild(li);
    }

    // select
    fillSelect(elFileSelect, '— выберите файл —', shown.map(x => x.rel));
    elFileSelect.disabled = false;
    btnOpenFile.disabled = true;

    // restore selected file from hash if present
    const h0 = hashGet();
    if (h0.f) {
      const idx = shown.findIndex(x => x.rel === h0.f);
      if (idx >= 0) {
        elFileSelect.value = shown[idx].rel;
        btnOpenFile.disabled = false;
      }
    }

    hashSet({ s: sDisp, a, sub: subDisp, pr: prDisp || '', f: elFileSelect.value || '', q: elFilter.value.trim(), t: elTask.value.trim() });
  }

  function escapeHtml(s) {
    return String(s)
            .replaceAll('&', '&amp;')
            .replaceAll('<', '&lt;')
            .replaceAll('>', '&gt;')
            .replaceAll('"', '&quot;')
            .replaceAll("'", '&#39;');
  }

  function scoreTaskCandidate(fileName, n) {
    const lower = fileName.toLowerCase();
    const num = String(Number(n));
    const numRe = new RegExp(`(^|[^0-9])${num}([^0-9]|$)`);

    if (lower === `task${num}.cpp`) return 100;
    if (lower === `${num}.cpp`) return 98;
    if (new RegExp(`^task[_-]?${num}\\.cpp$`, 'i').test(fileName)) return 95;
    if (new RegExp(`^${num}[_-]`, 'i').test(fileName)) return 90;
    if (numRe.test(lower)) return 80;
    if (lower.includes(num)) return 50;
    return 0;
  }

  function findBestByTask(files, taskNum) {
    const n = String(taskNum).trim();
    if (!n || isNaN(Number(n))) return null;

    let best = null;
    let bestScore = 0;

    for (const f of files) {
      const s = scoreTaskCandidate(f.name, n);
      if (s > bestScore) {
        bestScore = s;
        best = f;
      }
    }

    return bestScore > 0 ? best : null;
  }

  function updateAuthors() {
    const sDisp = elSemester.value;
    const s = semesterFromDisplay(sDisp);
    const sem = index.semesters[s];
    if (!sem) {
      elAuthor.disabled = true;
      elSubject.disabled = true;
      fillSelect(elAuthor, '— выберите автора —', []);
      fillSelect(elSubject, '— выберите раздел —', []);
      fillSelect(elPractice, '— выберите практику —', []);
      elPractice.disabled = true;
      setStatus('bad', `<span class="pill bad">ERR</span>Не найден семестр <code>${escapeHtml(sDisp)}</code> в индексе.`);
      renderFiles();
      return;
    }

    const authors = Object.keys(sem.authors).sort(byLocale);
    fillSelect(elAuthor, '— выберите автора —', authors);
    elAuthor.disabled = false;

    fillSelect(elSubject, '— выберите раздел —', []);
    elSubject.disabled = true;

    fillSelect(elPractice, '— выберите практику —', []);
    elPractice.disabled = true;

    setStatus('', 'Выберите автора.');
    renderFiles();
  }

  function updatePractices() {
    const h = hashGet();
    const { subject } = getCurrentModel();
    if (!subject) {
      fillSelect(elPractice, '— выберите практику —', []);
      elPractice.disabled = true;
      elPracticeWrap.classList.add('hidden');
      renderFiles();
      return;
    }

    const prs = Object.keys(subject.prs || {}).sort(byLocale);

    // Semester_1: HW_* treated as a single level, no separate practice UI
    const looksLikeHw = prs.length > 0 && prs.every(x => /^HW[_-]?\d+$/i.test(x));
    if (looksLikeHw) {
      fillSelect(elPractice, '—', ['—']);
      elPractice.value = '—';
      elPractice.disabled = true;
      elPracticeWrap.classList.add('hidden');
      hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });
      renderFiles();
      return;
    }

    elPracticeWrap.classList.remove('hidden');
    const practiceValues = prs.map(practiceToDisplay);
    fillSelect(elPractice, '— выберите практику —', practiceValues);
    elPractice.disabled = false;

    // restore from hash
    if (h.pr && Array.from(elPractice.options).some(o => o.value === h.pr)) {
      elPractice.value = h.pr;
    } else {
      elPractice.value = practiceValues[0] || '';
    }

    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: elPractice.value || '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });
    renderFiles();
  }

  function updateSubjects() {
    const { s, a } = getCurrentModel();
    const sem = index.semesters[s];
    const author = sem?.authors?.[a];

    if (!author) {
      elSubject.disabled = true;
      fillSelect(elSubject, '— выберите раздел —', []);
      fillSelect(elPractice, '— выберите практику —', []);
      elPractice.disabled = true;
      setStatus('bad', `<span class="pill bad">404</span>Для <b>${escapeHtml(a || '—')}</b> нет папки в <code>${escapeHtml(semesterToDisplay(s))}</code> (или нет файлов в ожидаемом формате).`);
      renderFiles();
      return;
    }

    const subjects = Object.keys(author.subjects).map(subjectToDisplay).sort(byLocale);
    fillSelect(elSubject, '— выберите раздел —', subjects);
    elSubject.disabled = false;

    fillSelect(elPractice, '— выберите практику —', []);
    elPractice.disabled = true;

    if (subjects.length === 0) {
      setStatus('bad', `<span class="pill bad">EMPTY</span>У <b>${escapeHtml(a)}</b> нет разделов (или в них нет файлов).`);
    } else {
      setStatus('', 'Выберите раздел.');
    }

    renderFiles();
  }

  function updateSelectionFromHash() {
    const h = hashGet();

    if (h.q) elFilter.value = h.q;
    if (h.t) elTask.value = h.t;

    // semester
    if (h.s && Array.from(elSemester.options).some(o => o.value === h.s)) {
      elSemester.value = h.s;
    }

    updateAuthors();

    // author
    if (h.a && Array.from(elAuthor.options).some(o => o.value === h.a)) {
      elAuthor.value = h.a;
      updateSubjects();
    }

    // subject
    if (h.sub && Array.from(elSubject.options).some(o => o.value === h.sub)) {
      elSubject.value = h.sub;
    }

    updatePractices();
  }

  // ===== events =====
  elSemester.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: '', sub: '', pr: '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });
    updateAuthors();
  });

  elAuthor.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: '', pr: '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });
    updateSubjects();
  });

  elSubject.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });

    const { subject } = getCurrentModel();
    if (!subject) {
      setStatus('bad', `<span class="pill bad">404</span>Этот предмет не найден в индексе.`);
    } else {
      const first = Object.values(subject.prs)[0];
      const folderPath = first ? (first.folderPath.split('/PR_')[0]) : '';
      setStatus('ok', `<span class="pill ok">OK</span>Найден раздел: <a href="${ghTree(folderPath)}" target="_blank" rel="noreferrer">${escapeHtml(elSemester.value + '/' + elAuthor.value + '/' + elSubject.value)}</a>`);
    }

    updatePractices();
  });

  elPractice.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: elPractice.value, f: '', q: elFilter.value.trim(), t: elTask.value.trim() });
    renderFiles();
  });

  elOnlyCpp.addEventListener('change', renderFiles);
  elFilter.addEventListener('input', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: elPractice.value || '', f: elFileSelect.value || '', q: elFilter.value.trim(), t: elTask.value.trim() });
    renderFiles();
  });

  elTask.addEventListener('input', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: elPractice.value || '', f: elFileSelect.value || '', q: elFilter.value.trim(), t: elTask.value.trim() });
  });

  elFileSelect.addEventListener('change', () => {
    const rel = elFileSelect.value;
    btnOpenFile.disabled = !rel;
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: elPractice.value || '', f: rel, q: elFilter.value.trim(), t: elTask.value.trim() });
  });

  btnOpenFolder.addEventListener('click', () => {
    const { subject, pr } = getCurrentModel();
    if (!subject) return;
    const selected = (pr && subject.prs?.[pr]) ? subject.prs[pr] : Object.values(subject.prs)[0];
    if (!selected) return;
    const folderPath = selected.folderPath.split('/PR_')[0];
    location.href = ghTree(folderPath);
  });

  btnOpenFile.addEventListener('click', () => {
    const { subject, pr } = getCurrentModel();
    if (!subject) return;
    const rel = elFileSelect.value;
    if (!rel) return;
    // Find file within selected practice first, then fallback
    let file = null;
    if (pr && subject.prs?.[pr]) {
      file = subject.prs[pr].files.find(x => x.rel === rel) || null;
    }
    if (!file) {
      for (const p of Object.values(subject.prs)) {
        file = p.files.find(x => x.rel === rel);
        if (file) break;
      }
    }
    if (!file) return;
    location.href = ghBlob(file.path);
  });

  btnFindTask.addEventListener('click', () => {
    const { subject, pr } = getCurrentModel();
    const task = elTask.value.trim();
    if (!subject) {
      setStatus('bad', `<span class="pill bad">ERR</span>Сначала выберите семестр/автора/раздел.`);
      return;
    }

    if (!task) {
      setStatus('ok', `<span class="pill ok">OK</span>Введите номер задачи, либо пользуйтесь списком файлов.`);
      return;
    }

    // Search within selected practice first, otherwise across all
    let allFiles = [];
    if (pr && subject.prs?.[pr]) {
      allFiles = subject.prs[pr].files.slice();
    } else {
      for (const p of Object.values(subject.prs)) {
        allFiles.push(...p.files);
      }
    }

    const best = findBestByTask(allFiles, task);
    if (!best) {
      const folderPath = Object.values(subject.prs)[0]?.folderPath.split('/PR_')[0] || '';
      setStatus('bad', `<span class="pill bad">NO</span>Не удалось сопоставить задачу <b>${escapeHtml(task)}</b> ни с одним файлом в <a href="${ghTree(folderPath)}" target="_blank" rel="noreferrer">${escapeHtml(elSemester.value + '/' + elAuthor.value + '/' + elSubject.value)}</a>.`);
      return;
    }

    setStatus('ok', `<span class="pill ok">FOUND</span>Задача <b>${escapeHtml(task)}</b> похожа на: <a href="${ghBlob(best.path)}" target="_blank" rel="noreferrer">${escapeHtml(best.rel)}</a>`);

    // try set in UI
    elFilter.value = '';
    elOnlyCpp.checked = best.name.toLowerCase().endsWith('.cpp');
    renderFiles();

    // select
    if (Array.from(elFileSelect.options).some(o => o.value === best.rel)) {
      elFileSelect.value = best.rel;
      btnOpenFile.disabled = false;
      hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: '', f: best.rel, q: elFilter.value.trim(), t: elTask.value.trim() });
    }
  });

  btnCopyLink.addEventListener('click', async () => {
    const url = location.origin + location.pathname + location.search + location.hash;
    const ok = await copyToClipboard(url);
    setStatus(ok ? 'ok' : 'bad', `${ok ? '<span class="pill ok">OK</span>' : '<span class="pill bad">ERR</span>'}Ссылка ${ok ? 'скопирована' : 'не скопирована'}: <code>${escapeHtml(url)}</code>`);
  });

  // ===== init =====
  (async function init() {
    try {
      setStatus('', `Загрузка индекса из ветки <code>${escapeHtml(REF)}</code>…`);

      const { tree, fromCache, truncated } = await loadTreeCached();
      if (truncated) {
        setStatus('bad', `<span class="pill bad">WARN</span>GitHub вернул <code>truncated=true</code> (репозиторий слишком большой для одного recursive tree). Индекс может быть неполным.`);
      }

      buildIndex(tree);

      const semesters = Object.keys(index.semesters).map(semesterToDisplay).sort(byLocale);
      if (semesters.length === 0) {
        setStatus('bad', `<span class="pill bad">EMPTY</span>Не найдено решений в формате <code>Semester_*/&lt;author&gt;/{OOP,AI_BigData,DataStructures,Informatics}/PR_*/...</code> в ветке <code>${escapeHtml(REF)}</code>.`);
        fillSelect(elSemester, '— семестр не найден —', []);
        elAuthor.disabled = true;
        elSubject.disabled = true;
        return;
      }

      fillSelect(elSemester, '— выберите семестр —', semesters);
      elSemester.value = semesters[0];

      updateSelectionFromHash();

      if (!truncated) {
        setStatus('ok', `${fromCache ? '<span class="pill ok">CACHE</span>' : '<span class="pill ok">OK</span>'}Индекс готов. Выберите автора и предмет.`);
      }
    } catch (err) {
      const msg = String(err);
      setStatus('bad', `<span class="pill bad">ERR</span>${escapeHtml(msg)}`);
    }
  })();
</script>
</body>
</html>