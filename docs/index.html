<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LearningCPP — Навигатор</title>
  <style>
    :root {
      --bg: #0d1117;
      --panel: #161b22;
      --text: #c9d1d9;
      --muted: #8b949e;
      --accent: #2f81f7;
      --ok: #3fb950;
      --bad: #f85149;
      --border: #30363d;
      --shadow: rgba(0,0,0,.35);
    }

    *, *::before, *::after { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
      background: var(--bg);
      color: var(--text);
    }
    header {
      padding: 20px 18px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, #0d1117 0%, #0b0f14 100%);
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(8px);
    }
    header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: .2px;
    }
    header p {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 10px 30px var(--shadow);
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 980px) {
      .grid {
        grid-template-columns: 1fr 1fr 1fr;
      }
    }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    select, input {
      width: 100%;
      min-width: 0;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0b0f14;
      color: var(--text);
      outline: none;
      box-sizing: border-box;
    }
    select:focus, input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(47,129,247,.18);
    }

    .row {
      margin-top: 12px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 980px) {
      .row {
        grid-template-columns: 1fr 1fr;
      }
    }

    /* Buttons: use grid to guarantee no overlaps on narrow widths */
    .btnrow {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(min(220px, 100%), 1fr));
      gap: 10px;
      align-items: stretch;
    }
    button {
      cursor: pointer;
      border: 1px solid var(--border);
      background: #0b0f14;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
      box-sizing: border-box;
      white-space: nowrap;
    }
    @media (max-width: 460px) {
      button {
        white-space: normal;
      }
    }
    button:hover { border-color: var(--accent); }
    button:disabled {
      cursor: not-allowed;
      opacity: .55;
    }

    .status {
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0b0f14;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    .status.ok { border-color: rgba(63,185,80,.45); }
    .status.bad { border-color: rgba(248,81,73,.45); }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      margin-right: 8px;
      vertical-align: baseline;
    }
    .pill.ok { color: var(--ok); border-color: rgba(63,185,80,.45); }
    .pill.bad { color: var(--bad); border-color: rgba(248,81,73,.45); }

    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    code { color: #d2a8ff; }

    .files {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
    }
    /* Header: switch from flex to grid so the select never overlaps other controls */
    .files-head {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(240px, 520px);
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      background: #0b0f14;
      border-bottom: 1px solid var(--border);
    }
    @media (max-width: 760px) {
      .files-head {
        grid-template-columns: 1fr;
      }
    }
    .files-head .left {
      display: inline-flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      min-width: 0;
    }
    .files-head .right {
      width: 100%;
      max-width: 520px;
      min-width: 0;
      justify-self: end;
    }
    @media (max-width: 760px) {
      .files-head .right {
        max-width: none;
        justify-self: stretch;
      }
    }
    .files-head small { color: var(--muted); }
    .files-list {
      max-height: 420px;
      overflow: auto;
      background: #0d1117;
    }
    ul { margin: 0; padding: 10px 18px; }
    li { margin: 6px 0; }

    .switch {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      user-select: none;
      cursor: pointer;
      color: var(--muted);
      font-size: 13px;
    }
    .switch input { width: auto; }

    footer {
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
  </style>
</head>
<body>
<header>
  <h1>LearningCPP — навигатор решений</h1>
  <p>Быстрый выбор «семестр → автор → предмет → ПР» и переход в нужную папку</p>
</header>

<main>
  <div class="card">
    <div class="grid">
      <div>
        <label for="semester">Семестр</label>
        <select id="semester"></select>
      </div>
      <div>
        <label for="author">Автор</label>
        <select id="author" disabled></select>
      </div>
      <div>
        <label for="subject">Предмет</label>
        <select id="subject" disabled></select>
      </div>
    </div>

    <div class="row">
      <div>
        <label for="task">Номер задачи (опционально, чтобы быстро найти файл)</label>
        <input id="task" inputmode="numeric" placeholder="Например: 1" />
      </div>
      <div>
        <label for="filter">Фильтр по имени файла (подстрока)</label>
        <input id="filter" placeholder="Например: task, matrix, 3" />
      </div>
    </div>

    <div class="btnrow">
      <button id="openFolder" disabled>Открыть папку предмета</button>
      <button id="findTask" disabled>Найти задачу</button>
      <button id="openFile" disabled>Открыть выбранный файл</button>
      <button id="copyLink">Скопировать ссылку</button>
    </div>

    <div id="status" class="status">Загрузка индекса…</div>

    <div id="files" class="files" style="display:none;">
      <div class="files-head">
        <div class="left">
          <span class="pill">FILES</span>
          <small id="filesMeta">—</small>
          <label class="switch" title="Показывать только .cpp">
            <input id="onlyCpp" type="checkbox" checked />
            Только .cpp
          </label>
        </div>
        <div class="right">
          <select id="fileSelect" disabled></select>
        </div>
      </div>
      <div class="files-list">
        <ul id="filesList"></ul>
      </div>
    </div>

    <footer>
      <div><span class="pill">SCAN</span>Ожидаемый формат решений: <code>Semester_*/&lt;author&gt;/{OOP,AI_BigData,DataStructures,Informatics}/PR_*/...</code>. Навигатор строит индекс одним запросом к Git Trees API и кэширует его в <code>localStorage</code>.</div>
      <div><span class="pill">TIP</span>Можно выбрать другую ветку через <code>?ref=master</code> или <code>?ref=Vennilay</code>.</div>
    </footer>
  </div>
</main>

<script>
  // ===== config =====
  const OWNER = 'Vennilay';
  const REPO  = 'LearningCPP';

  const qs = new URLSearchParams(location.search);
  const REF = (qs.get('ref') || 'Vennilay').trim();

  const SEMESTER_RE = /^Semester_\d+$/i;
  const SUBJECT_RE = /^(OOP|AI_BigData|DataStructures|Informatics)$/i;
  const PR_RE = /^PR[_-]?\d+$/i;

  // ===== elements =====
  const elSemester  = document.getElementById('semester');
  const elAuthor    = document.getElementById('author');
  const elSubject   = document.getElementById('subject');
  const elTask      = document.getElementById('task');
  const elFilter    = document.getElementById('filter');
  const elStatus    = document.getElementById('status');

  const elFilesWrap = document.getElementById('files');
  const elFilesMeta = document.getElementById('filesMeta');
  const elOnlyCpp   = document.getElementById('onlyCpp');
  const elFileSelect= document.getElementById('fileSelect');
  const elFilesList = document.getElementById('filesList');

  const btnOpenFolder = document.getElementById('openFolder');
  const btnFindTask   = document.getElementById('findTask');
  const btnOpenFile   = document.getElementById('openFile');
  const btnCopyLink   = document.getElementById('copyLink');

  // ===== helpers =====
  function setStatus(kind, html) {
    elStatus.className = 'status' + (kind ? ` ${kind}` : '');
    elStatus.innerHTML = html;
  }

  function ghTree(path) {
    const safe = path.split('/').filter(Boolean).map(encodeURIComponent).join('/');
    return `https://github.com/${OWNER}/${REPO}/tree/${encodeURIComponent(REF)}/${safe}`;
  }

  function ghBlob(path) {
    const safe = path.split('/').filter(Boolean).map(encodeURIComponent).join('/');
    return `https://github.com/${OWNER}/${REPO}/blob/${encodeURIComponent(REF)}/${safe}`;
  }

  function apiTreeUrl() {
    // GitHub REST API: GET /repos/{owner}/{repo}/git/trees/{tree_sha}?recursive=1
    return `https://api.github.com/repos/${OWNER}/${REPO}/git/trees/${encodeURIComponent(REF)}?recursive=1`;
  }

  function byLocale(a, b) {
    return a.localeCompare(b, 'en', { numeric: true, sensitivity: 'base' });
  }

  function hashGet() {
    const h = location.hash.replace(/^#/, '');
    const p = new URLSearchParams(h);
    return {
      s: p.get('s') || '',
      a: p.get('a') || '',
      sub: p.get('sub') || '',
      pr: p.get('pr') || '',
      f: p.get('f') || '',
      q: p.get('q') || '',
      t: p.get('t') || '',
    };
  }

  function hashSet({ s, a, sub, pr, f, q, t }) {
    const p = new URLSearchParams();
    if (s) p.set('s', s);
    if (a) p.set('a', a);
    if (sub) p.set('sub', sub);
    if (pr) p.set('pr', pr);
    if (f) p.set('f', f);
    if (q) p.set('q', q);
    if (t) p.set('t', t);
    const next = '#' + p.toString();
    if (location.hash !== next) history.replaceState(null, '', next);
  }

  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch {
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position = 'fixed';
      ta.style.left = '-9999px';
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand('copy');
      ta.remove();
      return ok;
    }
  }

  // ===== index model =====
  // index.semesters[semester].authors[author].subjects[subject].prs[pr] = { folderPath, files: [{path, rel, name}] }
  const index = { semesters: {} };

  function ensure(obj, key, init) {
    if (!obj[key]) obj[key] = init;
    return obj[key];
  }

  function buildIndex(treeItems) {
    index.semesters = {};

    for (const it of treeItems) {
      if (!it || it.type !== 'blob' || typeof it.path !== 'string') continue;

      const parts = it.path.split('/');
      if (parts.length < 5) continue;

      const [semester, author, subject, pr] = parts;
      if (!SEMESTER_RE.test(semester)) continue;
      if (!SUBJECT_RE.test(subject)) continue;
      if (!PR_RE.test(pr)) continue;

      const rel = parts.slice(4).join('/');
      const folderPath = `${semester}/${author}/${subject}/${pr}`;

      const sem = ensure(index.semesters, semester, { authors: {} });
      const a = ensure(sem.authors, author, { subjects: {} });
      const sub = ensure(a.subjects, subject, { prs: {} });
      const p = ensure(sub.prs, pr, { folderPath, files: [] });

      p.files.push({
        path: it.path,
        rel,
        name: parts[parts.length - 1],
      });
    }

    // normalize: sort everything
    for (const semester of Object.keys(index.semesters)) {
      const sem = index.semesters[semester];
      for (const author of Object.keys(sem.authors)) {
        const a = sem.authors[author];
        for (const subject of Object.keys(a.subjects)) {
          const sub = a.subjects[subject];
          for (const pr of Object.keys(sub.prs)) {
            sub.prs[pr].files.sort((x, y) => byLocale(x.rel, y.rel));
          }
        }
      }
    }
  }

  async function loadTreeCached() {
    const key = `lc-tree:${OWNER}/${REPO}@${REF}`;
    const cachedRaw = localStorage.getItem(key);
    let cached = null;

    if (cachedRaw) {
      try { cached = JSON.parse(cachedRaw); } catch { cached = null; }
    }

    const headers = { 'Accept': 'application/vnd.github+json' };
    if (cached && cached.etag) headers['If-None-Match'] = cached.etag;

    const res = await fetch(apiTreeUrl(), { headers });

    if (res.status === 304 && cached && cached.tree) {
      return { tree: cached.tree, fromCache: true, truncated: !!cached.truncated };
    }

    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`GitHub API error: ${res.status} ${text}`);
    }

    const json = await res.json();
    const etag = res.headers.get('ETag');

    const payload = {
      fetchedAt: Date.now(),
      etag,
      truncated: !!json.truncated,
      tree: Array.isArray(json.tree) ? json.tree : [],
    };

    try { localStorage.setItem(key, JSON.stringify(payload)); } catch {}

    return { tree: payload.tree, fromCache: false, truncated: payload.truncated };
  }

  function fillSelect(el, placeholder, values) {
    el.innerHTML = '';
    const ph = document.createElement('option');
    ph.value = '';
    ph.textContent = placeholder;
    el.appendChild(ph);

    for (const v of values) {
      const opt = document.createElement('option');
      opt.value = v;
      opt.textContent = v;
      el.appendChild(opt);
    }
  }

  function getCurrentModel() {
    const s = elSemester.value;
    const a = elAuthor.value;
    const sub = elSubject.value;
    const sem = index.semesters[s];
    const author = sem?.authors?.[a];
    const subject = author?.subjects?.[sub];
    return { s, a, sub, subject };
  }

  function renderFiles() {
    const { s, a, sub, subject } = getCurrentModel();

    const filter = elFilter.value.trim().toLowerCase();
    const onlyCpp = !!elOnlyCpp.checked;

    elFilesList.innerHTML = '';

    if (!subject) {
      elFilesWrap.style.display = 'none';
      elFileSelect.disabled = true;
      btnOpenFolder.disabled = true;
      btnFindTask.disabled = true;
      btnOpenFile.disabled = true;
      return;
    }

    // Merge files from all PRs in this subject
    const allFiles = [];
    for (const pr of Object.values(subject.prs)) {
      allFiles.push(...pr.files);
    }

    const shown = allFiles.filter(f => {
      if (onlyCpp && !f.name.toLowerCase().endsWith('.cpp')) return false;
      if (filter && !f.rel.toLowerCase().includes(filter)) return false;
      return true;
    });

    btnOpenFolder.disabled = false;
    btnFindTask.disabled = false;

    elFilesWrap.style.display = '';
    elFilesMeta.textContent = `${s} / ${a} / ${sub} — файлов: ${shown.length} (всего ${allFiles.length})`;

    // list
    for (const f of shown) {
      const li = document.createElement('li');
      li.innerHTML = `<a href="${ghBlob(f.path)}" target="_blank" rel="noreferrer">${escapeHtml(f.rel)}</a>`;
      elFilesList.appendChild(li);
    }

    // select
    fillSelect(elFileSelect, '— выберите файл —', shown.map(x => x.rel));
    elFileSelect.disabled = false;
    btnOpenFile.disabled = true;

    // restore selected file from hash if present
    const h0 = hashGet();
    if (h0.f) {
      const idx = shown.findIndex(x => x.rel === h0.f);
      if (idx >= 0) {
        elFileSelect.value = shown[idx].rel;
        btnOpenFile.disabled = false;
      }
    }

    hashSet({ s, a, sub, pr: '', f: elFileSelect.value || '', q: elFilter.value.trim(), t: elTask.value.trim() });
  }

  function escapeHtml(s) {
    return String(s)
            .replaceAll('&', '&amp;')
            .replaceAll('<', '&lt;')
            .replaceAll('>', '&gt;')
            .replaceAll('"', '&quot;')
            .replaceAll("'", '&#39;');
  }

  function scoreTaskCandidate(fileName, n) {
    const lower = fileName.toLowerCase();
    const num = String(Number(n));
    const numRe = new RegExp(`(^|[^0-9])${num}([^0-9]|$)`);

    if (lower === `task${num}.cpp`) return 100;
    if (lower === `${num}.cpp`) return 98;
    if (new RegExp(`^task[_-]?${num}\\.cpp$`, 'i').test(fileName)) return 95;
    if (new RegExp(`^${num}[_-]`, 'i').test(fileName)) return 90;
    if (numRe.test(lower)) return 80;
    if (lower.includes(num)) return 50;
    return 0;
  }

  function findBestByTask(files, taskNum) {
    const n = String(taskNum).trim();
    if (!n || isNaN(Number(n))) return null;

    let best = null;
    let bestScore = 0;

    for (const f of files) {
      const s = scoreTaskCandidate(f.name, n);
      if (s > bestScore) {
        bestScore = s;
        best = f;
      }
    }

    return bestScore > 0 ? best : null;
  }

  function updateAuthors() {
    const s = elSemester.value;
    const sem = index.semesters[s];
    if (!sem) {
      elAuthor.disabled = true;
      elSubject.disabled = true;
      fillSelect(elAuthor, '— выберите автора —', []);
      fillSelect(elSubject, '— выберите предмет —', []);
      setStatus('bad', `<span class="pill bad">ERR</span>Не найден семестр <code>${escapeHtml(s)}</code> в индексе.`);
      renderFiles();
      return;
    }

    const authors = Object.keys(sem.authors).sort(byLocale);
    fillSelect(elAuthor, '— выберите автора —', authors);
    elAuthor.disabled = false;

    fillSelect(elSubject, '— выберите предмет —', []);
    elSubject.disabled = true;

    setStatus('', 'Выберите автора.');
    renderFiles();
  }

  function updateSubjects() {
    const { s, a } = getCurrentModel();
    const sem = index.semesters[s];
    const author = sem?.authors?.[a];

    if (!author) {
      elSubject.disabled = true;
      fillSelect(elSubject, '— выберите предмет —', []);
      setStatus('bad', `<span class="pill bad">404</span>Для <b>${escapeHtml(a || '—')}</b> нет папки в <code>${escapeHtml(s)}</code> (или нет файлов в формате предметов).`);
      renderFiles();
      return;
    }

    const subjects = Object.keys(author.subjects).sort(byLocale);
    fillSelect(elSubject, '— выберите предмет —', subjects);
    elSubject.disabled = false;

    if (subjects.length === 0) {
      setStatus('bad', `<span class="pill bad">EMPTY</span>У <b>${escapeHtml(a)}</b> нет предметов (или в них нет файлов).`);
    } else {
      setStatus('', 'Выберите предмет.');
    }

    renderFiles();
  }

  function updateSelectionFromHash() {
    const h = hashGet();

    if (h.q) elFilter.value = h.q;
    if (h.t) elTask.value = h.t;

    // semester
    if (h.s && Array.from(elSemester.options).some(o => o.value === h.s)) {
      elSemester.value = h.s;
    }

    updateAuthors();

    // author
    if (h.a && Array.from(elAuthor.options).some(o => o.value === h.a)) {
      elAuthor.value = h.a;
      updateSubjects();
    }

    // subject
    if (h.sub && Array.from(elSubject.options).some(o => o.value === h.sub)) {
      elSubject.value = h.sub;
    }

    renderFiles();
  }

  // ===== events =====
  elSemester.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: '', sub: '', pr: '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });
    updateAuthors();
  });

  elAuthor.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: '', pr: '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });
    updateSubjects();
  });

  elSubject.addEventListener('change', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: '', f: '', q: elFilter.value.trim(), t: elTask.value.trim() });

    const { subject } = getCurrentModel();
    if (!subject) {
      setStatus('bad', `<span class="pill bad">404</span>Этот предмет не найден в индексе.`);
    } else {
      setStatus('ok', `<span class="pill ok">OK</span>Найден предмет: <a href="${ghTree(subject.prs[Object.keys(subject.prs)[0]].folderPath.split('/PR_')[0])}" target="_blank" rel="noreferrer">${escapeHtml(elSemester.value + '/' + elAuthor.value + '/' + elSubject.value)}</a>`);
    }

    renderFiles();
  });

  elOnlyCpp.addEventListener('change', renderFiles);
  elFilter.addEventListener('input', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: '', f: elFileSelect.value || '', q: elFilter.value.trim(), t: elTask.value.trim() });
    renderFiles();
  });

  elTask.addEventListener('input', () => {
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: '', f: elFileSelect.value || '', q: elFilter.value.trim(), t: elTask.value.trim() });
  });

  elFileSelect.addEventListener('change', () => {
    const rel = elFileSelect.value;
    btnOpenFile.disabled = !rel;
    hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: '', f: rel, q: elFilter.value.trim(), t: elTask.value.trim() });
  });

  btnOpenFolder.addEventListener('click', () => {
    const { subject } = getCurrentModel();
    if (!subject) return;
    const firstPr = Object.values(subject.prs)[0];
    if (!firstPr) return;
    const folderPath = firstPr.folderPath.split('/PR_')[0];
    location.href = ghTree(folderPath);
  });

  btnOpenFile.addEventListener('click', () => {
    const { subject } = getCurrentModel();
    if (!subject) return;
    const rel = elFileSelect.value;
    if (!rel) return;
    // Find file across all PRs in this subject
    let file = null;
    for (const pr of Object.values(subject.prs)) {
      file = pr.files.find(x => x.rel === rel);
      if (file) break;
    }
    if (!file) return;
    location.href = ghBlob(file.path);
  });

  btnFindTask.addEventListener('click', () => {
    const { subject } = getCurrentModel();
    const task = elTask.value.trim();
    if (!subject) {
      setStatus('bad', `<span class="pill bad">ERR</span>Сначала выберите семестр/автора/предмет.`);
      return;
    }

    if (!task) {
      setStatus('ok', `<span class="pill ok">OK</span>Введите номер задачи, либо пользуйтесь списком файлов.`);
      return;
    }

    // Merge all files from all PRs
    const allFiles = [];
    for (const pr of Object.values(subject.prs)) {
      allFiles.push(...pr.files);
    }

    const best = findBestByTask(allFiles, task);
    if (!best) {
      const folderPath = Object.values(subject.prs)[0]?.folderPath.split('/PR_')[0] || '';
      setStatus('bad', `<span class="pill bad">NO</span>Не удалось сопоставить задачу <b>${escapeHtml(task)}</b> ни с одним файлом в <a href="${ghTree(folderPath)}" target="_blank" rel="noreferrer">${escapeHtml(elSemester.value + '/' + elAuthor.value + '/' + elSubject.value)}</a>.`);
      return;
    }

    setStatus('ok', `<span class="pill ok">FOUND</span>Задача <b>${escapeHtml(task)}</b> похожа на: <a href="${ghBlob(best.path)}" target="_blank" rel="noreferrer">${escapeHtml(best.rel)}</a>`);

    // try set in UI
    elFilter.value = '';
    elOnlyCpp.checked = best.name.toLowerCase().endsWith('.cpp');
    renderFiles();

    // select
    if (Array.from(elFileSelect.options).some(o => o.value === best.rel)) {
      elFileSelect.value = best.rel;
      btnOpenFile.disabled = false;
      hashSet({ s: elSemester.value, a: elAuthor.value, sub: elSubject.value, pr: '', f: best.rel, q: elFilter.value.trim(), t: elTask.value.trim() });
    }
  });

  btnCopyLink.addEventListener('click', async () => {
    const url = location.origin + location.pathname + location.search + location.hash;
    const ok = await copyToClipboard(url);
    setStatus(ok ? 'ok' : 'bad', `${ok ? '<span class="pill ok">OK</span>' : '<span class="pill bad">ERR</span>'}Ссылка ${ok ? 'скопирована' : 'не скопирована'}: <code>${escapeHtml(url)}</code>`);
  });

  // ===== init =====
  (async function init() {
    try {
      setStatus('', `Загрузка индекса из ветки <code>${escapeHtml(REF)}</code>…`);

      const { tree, fromCache, truncated } = await loadTreeCached();
      if (truncated) {
        setStatus('bad', `<span class="pill bad">WARN</span>GitHub вернул <code>truncated=true</code> (репозиторий слишком большой для одного recursive tree). Индекс может быть неполным.`);
      }

      buildIndex(tree);

      const semesters = Object.keys(index.semesters).sort(byLocale);
      if (semesters.length === 0) {
        setStatus('bad', `<span class="pill bad">EMPTY</span>Не найдено решений в формате <code>Semester_*/&lt;author&gt;/{OOP,AI_BigData,DataStructures,Informatics}/PR_*/...</code> в ветке <code>${escapeHtml(REF)}</code>.`);
        fillSelect(elSemester, '— семестр не найден —', []);
        elAuthor.disabled = true;
        elSubject.disabled = true;
        return;
      }

      fillSelect(elSemester, '— выберите семестр —', semesters);
      elSemester.value = semesters[0];

      updateSelectionFromHash();

      if (!truncated) {
        setStatus('ok', `${fromCache ? '<span class="pill ok">CACHE</span>' : '<span class="pill ok">OK</span>'}Индекс готов. Выберите автора и предмет.`);
      }
    } catch (err) {
      const msg = String(err);
      setStatus('bad', `<span class="pill bad">ERR</span>${escapeHtml(msg)}`);
    }
  })();
</script>
</body>
</html>